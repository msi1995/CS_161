/********************************************************************************************
** Program: assignment5.cpp

** Author: Doug Lloyd

** Date: 12/06/2019

** Description: Plays the game Connect Four, allowing the user to select
	between two player modes and 1 player mode vs computer player.

** Input: Uses command line input to generate connect four board up to 20x20,
	and to select 1p or 2p mode.

** Output: For 1p game, generates a Connect Four board of user-defined size
	and has a computer randomly drop pieces to allow for a player to play alone.
	For a 2p game, alternates back and forth between each player allowing them to
	each drop a piece per turn.
*******************************************************************************************/

#include <iostream>
#include <cstdlib>
#include <stdio.h>      
#include <stdlib.h>     
#include <time.h>       

using namespace std;

void print_board(char**, int, int);
void runtime_recover(int&, int&, int&);
char** create_board(int, int);
bool bad_command(int, char**);
bool runtime_bad_command(int, int, int);
void play_game_2p(char**, int, int&, int&);
void play_game_1p(char**, int, int&, int&, int);
bool check_tie(char**, int, int);




int main(int argc, char** argv) {
	srand(time(NULL));
	int repeat = 1;
	while (repeat == 1) {
		int players, cols, rows, choice, counter;
		int player = 1;
		int validnum = 0;

		if (bad_command(argc, argv))
			runtime_recover(players, cols, rows);
		else {
			players = atoi(argv[1]);
			cols = atoi(argv[2]);
			rows = atoi(argv[3]);
		}

		while (runtime_bad_command(players, cols, rows))
			runtime_recover(players, cols, rows);


		char** board = create_board(rows, cols);

		/*This section goes into the 2P or 1P mode depending on the user's choice. I wasn't sure how to consolidate this
		 and was on a bit of a time crunch. It took up a lot of lines.*/
		if (players == 2) {
			cout << endl;
			print_board(board, rows, cols);
			play_game_2p(board, validnum, rows, cols);
		}
		else {
			cout << endl << "Press 1 to have first move, or 2 to let the computer go first. ";
			cin >> player;
			print_board(board, rows, cols);
			play_game_1p(board, validnum, rows, cols, player);
		}




		cout << "Repeat game? (1 Yes, 0 No) ";
		cin >> repeat;
		for (int i = 0; i < rows; i++) {
				delete[] board[i];
			}
			delete[] board;
	}
	return 0;
}

/*********************************************************************
** Function: char** create board(int rows, int cols)
** Description: This function receives the user inputted rows and cols 
	parameters from main and generates a dynamic 2D array of that size.
	It also populates all positions with spaces so that the board will
	not become messed up when placing X or O.
** Parameters: int, int
** Pre-Conditions: valid integer for rows and cols
** Post-Conditions: Returns a dynamic 2d array
*********************************************************************/
char** create_board(int rows, int cols) {
	char** board = new char* [rows];
	for (int i = 0; i < rows; ++i)
		board[i] = new char[cols];

	for (int i = 0; i < rows; i++) {
		for (int k = 0; k < cols; k++) {
			board[i][k] = ' ';
		}
	}

	return board;
}

/*********************************************************************
** Function: void print_board(char** board, int rows, int cols)
** Description: This function receives the 2D dynamic array previously 
	generated by create_board and actually prints it to the terminal.
	It sets a black and white background with proper spacing, and
	places column numbers above each column.
** Parameters: char** (2D Array), int, int
** Pre-Conditions: Valid 2D array, rows and cols
** Post-Conditions: Prints 2D array with column numbers to terminal
*********************************************************************/
void print_board(char** board, int rows, int cols) {
	for (int i = 0; i < cols; i++) {
		if (i < 10)
			cout << "  " << i << " ";
		else
			cout << "  " << i;
	}
	cout << endl;

	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < cols; j++)
		{
			if (i % 2 == 0 && j % 2 == 0)
				cout << "|\033[30;47m " << board[i][j] << " ";
			else if (i % 2 == 1 && j % 2 == 1)
				cout << "|\033[30;47m " << board[i][j] << " ";
			else
				cout << "|\033[0m " << board[i][j] << " ";
			cout << "\033[0m";
		}
		cout << endl;
	}
	cout << endl;
}

/*********************************************************************
** Function: bool bad_command(int, char**)
** Description: This function checks the command line values to ensure
	that they fall within proper ranges (0-20 for int) and that there
	are 4 arguments. If these conditions are not all met, the function
	returns false and I use this to feed into a recovery function.
** Parameters: int, char**
** Pre-Conditions: Valid command line arguments, and 4 arguments
** Post-Conditions: Returns true or false depending on command input
*********************************************************************/
bool bad_command(int argc, char** argv){
	if ((argc != 4) || (atoi(argv[1]) < 1) || (atoi(argv[1]) > 2) || (atoi(argv[2]) > 20) || (atoi(argv[3]) > 20)) {
		cout << endl << "Command line values are not correct. Must enter executable followed by number of players, rows, and cols.";
		cout << endl << "For example: 'a.out 2 10 10' will initialize game with 2 players on a 10x10 board." << endl << endl;
		return true;
	}
	else return false;
}

/*********************************************************************
** Function: runtime_bad_command(int players, int cols, int rows)
** Description: This function is used when the user has inputted bad
	command line arguments, and runtime_recover has been called. 
	runtime_recover is another function that prompts the user to input
	the game parameters during runtime. This function checks to see if
	the runtime parameters supplied by the user are correct. 
** Parameters: int, int, int
** Pre-Conditions: Receive user inputs from runtime_recover
** Post-Conditions: Returns true or false depending on valid inputs
*********************************************************************/
bool runtime_bad_command(int players, int cols, int rows) {
	if ((players < 1) || (players > 2) || (cols > 20) || (rows > 20)) {
		cout << "Please enter valid choices. 1-2 players, not more than 20 rows/columns." << endl;
		return true;
	}
	else return false;
}

/*********************************************************************
** Function: void runtime_recover(int& players, int& cols, int& rows)
** Description: This function is called when runtime_bad_command or
	bad_command return true, highlighting incorrect user input. It
	re-prompts the user to enter players, cols, and rows, and changes
	them inside of main since the parameters are passed by reference.
** Parameters: int&, int&, int&
** Pre-Conditions: runtime_bad_command or bad_command == true
** Post-Conditions: Changes players, cols, rows in main to valid values.
*********************************************************************/
void runtime_recover(int& players, int& cols, int& rows) {
	cout << "Enter number of players: ";
	cin >> players;
	cout << endl << "Enter number of cols: ";
	cin >> cols;
	cout << endl << "Enter number of rows: ";
	cin >> rows;
}


/*********************************************************************
** Function: play_game_2p(char** board, int validnum, int& rows, int& cols)
** Description: This function is the main part of the program. It allows
	the user to select a column to drop their piece in, checks that the
	column is not full, and places the piece at the lowest empty position
	available. It alternates between player 1 and player 2, and calls the 
	print_board and check_tie function after every move to reprint the
	board, and quit the function if there is a tie.
** Parameters: char**, int, int&, int&
** Pre-Conditions: Valid 2D array, row and column size to ensure valid user input
** Post-Conditions: Prints game board after every move.
*********************************************************************/
void play_game_2p(char** board, int validnum, int& rows, int& cols) {
	int winner = 0;
	int player = 1;
	while (winner == 0) {
		int choice;
		if (player == 1) {
			validnum = 0;
			while (validnum == 0) {
				cout << "Player 1, pick a column to drop your piece: ";
				cin >> choice;
				if (choice >= 0 && choice < cols)
					validnum = 1;
			}
		}
		else {
			validnum = 0;
			while (validnum == 0) {
				cout << "Player 2, pick a column to drop your piece: ";
				cin >> choice;
				if (choice >= 0 && choice < cols)
					validnum = 1;
			}
		}


		if (player == 1) {
			for (int j = 0; j < rows; j++) {
				if (board[rows - 1 - j][choice] != 'X' && board[rows - 1 - j][choice] != 'O') {
					board[rows - 1 - j][choice] = 'X';
					player = 2;
					break;
				}
			}
		}
		else {
			for (int k = 0; k < rows; k++) {
				if (board[rows - 1 - k][choice] != 'O' && board[rows - 1 - k][choice] != 'X') {
					board[rows - 1 - k][choice] = 'O';
					player = 1;
					break;
				}
			}
		}
		print_board(board, rows, cols);
		if (check_tie(board, rows, cols) == true) {
			cout << "Game is tied! Better luck next time!" << endl;
			return;
		}
	}
}

/*********************************************************************
** Function: play_game_1p(char** board, int validnum, int& rows, int& cols, int player)
** Description: This function is the main part of the program. It allows
	the user to select a column to drop their piece in, checks that the
	column is not full, and places the piece at the lowest empty position
	available. It also contains a rudimentary computer player which randomly
	places a piece on the board so that the game can be played with 1 player.
	It calls the print_board and check_tie function after every move to reprint
	the board, and quits the function if there is a tie.
** Parameters: char**, int, int&, int&, int
** Pre-Conditions: Valid 2D array, row and column size to ensure valid user input
** Post-Conditions: Prints game board after every move.
*********************************************************************/
void play_game_1p(char** board, int validnum, int& rows, int& cols, int player) {
	int winner = 0;
	int randnum;
	int randomrange = rows;

	while (winner == 0) {
		int choice;
		if (player == 1) {
			validnum = 0;
			while (validnum == 0) {
				cout << "Player 1, pick a column to drop your piece: ";
				cin >> choice;
				if (choice >= 0 && choice < cols)
					validnum = 1;
			}
		}

		if (player == 1) {
			for (int j = 0; j < rows; j++) {
				if (board[rows - 1 - j][choice] != 'X' && board[rows - 1 - j][choice] != 'O') {
					board[rows - 1 - j][choice] = 'X';
					player = 2;
					break;
				}
			}
		}
		else {
			randnum = rand() % randomrange;
			for (int k = 0; k < rows; k++) {
				if (board[rows - 1 - k][randnum] != 'O' && board[rows - 1 - k][randnum] != 'X') {
					board[rows - 1 - k][randnum] = 'O';
					player = 1;
					print_board(board, rows, cols);
					break;
				}
			}
		}
		if (check_tie(board, rows, cols) == true) {
			cout << "Game is tied! Better luck next time!" << endl;
			return;
		}
	}
}

/*********************************************************************
** Function: bool check_tie(char** board, int rows, int cols)
** Description: This function detects a tie if the board is full. It does
	this by checking for the presence of a space character anywhere in 
	the array.
** Parameters: char**, int, int
** Pre-Conditions: Valid 2D array, row and column size to loop through arr
** Post-Conditions: Return true if array is filled, false otherwise.
*********************************************************************/
bool check_tie(char** board, int rows, int cols) {
	int tie = 1;
	for (int i = 0; i < rows; i++) {
		for (int k = 0; k < cols; k++) {
			if (board[i][k] == ' '){
				tie = 0;
				break;
			}
		}
	}

	if (tie == 1) {
		return true;
	}
	else return false;
}